use serde::{Deserialize, Serialize};
use wasm_bindgen::{prelude::wasm_bindgen, JsValue};

#[wasm_bindgen()]
extern "C" {

    /// Vibrate the device
    #[wasm_bindgen(js_namespace = ["Capacitor", "Plugins", "Haptics"])]
    async fn vibrate(options: JsValue);

    #[wasm_bindgen(js_namespace = ["Capacitor", "Plugins", "Haptics"])]
    async fn impact(options: JsValue);

    /// Trigger a haptics "notification" feedback
    #[wasm_bindgen(js_namespace = ["Capacitor", "Plugins", "Haptics"])]
    async fn notification(options: JsValue);

    /// Trigger a selection started haptic hint
    #[wasm_bindgen(js_namespace = ["Capacitor", "Plugins", "Haptics"])]
    async fn selectionStart();

    /// Trigger a selection changed haptic hint. If a selection was started already, this will cause the device to provide haptic feedback
    #[wasm_bindgen(js_namespace = ["Capacitor", "Plugins", "Haptics"])]
    async fn selectionChanged();

    /// If selectionStart() was called, selectionEnd() ends the selection. For example, call this when a user has lifted their finger from a control
    #[wasm_bindgen(js_namespace = ["Capacitor", "Plugins", "Haptics"])]
    async fn selectionEnd();
}

pub struct Haptics;

impl Haptics {
    /// Trigger a haptics "impact" feedback
    pub fn impact(options: &ImpactOptions) {
        let js_val = serde_wasm_bindgen::to_value(options).unwrap();
        wasm_bindgen_futures::spawn_local(impact(js_val));
    }

    /// Vibrate the device
    pub fn vibrate(options: &VibrateOptions) {
        let js_val = serde_wasm_bindgen::to_value(options).unwrap();
        wasm_bindgen_futures::spawn_local(vibrate(js_val));
    }

    /// Trigger a haptics "notification" feedback
    pub fn notification(options: &NotificationOptions) {
        let js_val = serde_wasm_bindgen::to_value(options).unwrap();
        wasm_bindgen_futures::spawn_local(notification(js_val));
    }

    pub fn selection_start() {
        wasm_bindgen_futures::spawn_local(selectionStart());
    }

    pub fn selection_changed() {
        wasm_bindgen_futures::spawn_local(selectionChanged());
    }

    pub fn selection_end() {
        wasm_bindgen_futures::spawn_local(selectionEnd());
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VibrateOptions {
    /// Duration of the vibration in milliseconds.
    pub duration: f64,
}

impl Default for VibrateOptions {
    fn default() -> Self {
        Self { duration: 300.0 }
    }
}

#[derive(Debug, Serialize, Deserialize, Copy, Clone)]
pub struct NotificationOptions {
    /// Notification Feedback Type The type of notification feedback generated by a UINotificationFeedbackGenerator object.
    #[serde(rename = "type")]
    pub notification_type: NotificationType,
}

#[derive(Debug, Serialize, Deserialize, Copy, Clone)]
pub enum NotificationType {
    /// A notification feedback type indicating that a task has completed successfully
    #[serde(rename = "SUCCESS")]
    Success,
    /// A notification feedback type indicating that a task has produced a warning
    #[serde(rename = "WARNING")]
    Warning,
    /// A notification feedback type indicating that a task has failed
    #[serde(rename = "ERROR")]
    Error,
}

#[derive(Debug, Serialize, Deserialize, Copy, Clone)]
pub struct ImpactOptions {
    /// Impact Feedback Style The mass of the objects in the collision simulated by a UIImpactFeedbackGenerator object.
    pub style: ImpactStyle,
}

#[derive(Debug, Serialize, Deserialize, Copy, Clone)]
pub enum ImpactStyle {
    /// A collision between large, heavy user interface elements
    #[serde(rename = "HEAVY")]
    Heavy,
    /// A collision between moderately sized user interface elements
    #[serde(rename = "MEDIUM")]
    Medium,
    /// A collision between small, light user interface elements
    #[serde(rename = "LIGHT")]
    Light,
}
